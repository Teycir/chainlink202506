// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {MedusaHarness}  from "./MedusaHarness.sol";
import {IBUILDFactory}  from "../src/interfaces/IBUILDFactory.sol";
import {IBUILDClaim}    from "../src/interfaces/IBUILDClaim.sol";

/*  Target-specific exploit checks  */
contract ExploitSuite is MedusaHarness {

  /* ─────────────────────────────────────────────────────────────── */
  /*  Exploit 1: duplicated params should NOT double-pay a claim     */
  /* ─────────────────────────────────────────────────────────────── */
  function checkExploit_DoubleSpendInBatchClaim(
      address usr, uint256 amt, uint256 salt
  ) external {
    if (usr == address(0)) usr = address(0xDEAD);
    amt = (amt % 1e24) + 1;

    /* give user a single-leaf merkle root for SEASON0 */
    (IBUILDFactory.ProjectSeasonConfig memory cfg,) =
        factory.getProjectSeasonConfig(address(token), SEASON0);
    if (cfg.tokenAmount == 0) return;

    cfg.merkleRoot = keccak256(bytes.concat(
      keccak256(abi.encode(usr, amt, false, salt))
    ));
    IBUILDFactory.SetProjectSeasonParams[] memory set =
      new IBUILDFactory.SetProjectSeasonParams[](1);
    set[0] = IBUILDFactory.SetProjectSeasonParams({
      token: address(token),
      seasonId: SEASON0,
      config: cfg
    });
    factory.setProjectSeasonConfig(set);

    /* expected amount from a single claim */
    uint256 claimable = claim.getCurrentClaimValues(usr, SEASON0, amt).claimable;
    if (claimable == 0) return;

    /* craft duplicated params array */
    IBUILDClaim.ClaimParams[] memory p = new IBUILDClaim.ClaimParams[](2);
    p[0] = IBUILDClaim.ClaimParams({
      seasonId: SEASON0,
      proof: new bytes32[](0),
      maxTokenAmount: amt,
      salt: salt,
      isEarlyClaim: false
    });
    p[1] = p[0];

    uint256 balBefore = token.balanceOf(usr);

    /* external call – ignore revert, we only check final delta */
    address(claim).call(abi.encodeWithSelector(IBUILDClaim.claim.selector, usr, p));

    uint256 delta = token.balanceOf(usr) - balBefore;
    assert(delta <= claimable);          // must not exceed single payout
  }

  /* ─────────────────────────────────────────────────────────────── */
  /*  Exploit 2: unauthorized early-vest must revert                 */
  /* ─────────────────────────────────────────────────────────────── */
  function checkExploit_UnauthorizedEarlyClaim(
      address claimant,
      address attacker,
      uint256 amt,
      uint256 salt
  ) external {
    if (claimant == address(0) || attacker == address(0) || claimant == attacker) return;

    registry.set(claimant, attacker, false);             // ensure no delegation

    amt = (amt % 1e24) + 1;

    /* build merkle for early-claim */
    (IBUILDFactory.ProjectSeasonConfig memory cfg,) =
        factory.getProjectSeasonConfig(address(token), SEASON0);
    if (cfg.tokenAmount == 0) return;

    cfg.merkleRoot = keccak256(bytes.concat(
      keccak256(abi.encode(claimant, amt, true, salt))
    ));
    IBUILDFactory.SetProjectSeasonParams[] memory set =
      new IBUILDFactory.SetProjectSeasonParams[](1);
    set[0] = IBUILDFactory.SetProjectSeasonParams({
      token: address(token),
      seasonId: SEASON0,
      config: cfg
    });
    factory.setProjectSeasonConfig(set);

    IBUILDClaim.ClaimParams[] memory cp = new IBUILDClaim.ClaimParams[](1);
    cp[0] = IBUILDClaim.ClaimParams({
      seasonId: SEASON0,
      proof: new bytes32[](0),
      maxTokenAmount: amt,
      salt: salt,
      isEarlyClaim: true
    });

    /* attacker tries early-vest */
    (bool ok, bytes memory reason) =
      address(claim).call(abi.encodeWithSelector(IBUILDClaim.claim.selector, claimant, cp));

    /* must revert with InvalidSender selector */
    require(!ok && reason.length >= 4
            && bytes4(reason) == IBUILDClaim.InvalidSender.selector,
            "unauthorized early-vest succeeded or wrong revert");
  }

  /* ─────────────────────────────────────────────────────────────── */
  /*  Property: user.claimed ≤ maxTokenAmount (basic upper bound)    */
  /* ─────────────────────────────────────────────────────────────── */
  function checkProperty_UserClaimIsBounded(address usr, uint256 max) external view {
    if (usr == address(0)) return;
    max = (max % 1e24) + 1;

    IBUILDClaim.UserSeasonId[] memory id = new IBUILDClaim.UserSeasonId[](1);
    id[0] = IBUILDClaim.UserSeasonId({user: usr, seasonId: SEASON0});
    IBUILDClaim.UserState[] memory st = claim.getUserState(id);

    assert(st[0].claimed <= max);
  }
}